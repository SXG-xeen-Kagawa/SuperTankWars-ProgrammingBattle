#region MOVE

        [Header("<Move>")]
        [SerializeField, Tooltip("目標座標のランダム抽選半径")] float m_goalRadius = GameConstants.ABOUT_GAME_FIELD_RADIUS;
        [SerializeField, Tooltip("到達判定距離")] float m_goalReachRadius = 1.0f;
        [SerializeField, Tooltip("目標再抽選までの時間")] float m_goalTimeoutSec = 4.0f;
        [SerializeField, Tooltip("基本となる移動の強さ"), Range(0.1f,1.0f)] float m_movePower = 1.0f;

        float m_moveTimer = 0;
        Vector3 m_goal;


        void DoMove()
        {
            // 残り時間 
            m_moveTimer -= Time.deltaTime;

            // 目的地までの距離 
            Vector3 toGoal = m_goal - m_nowPosition;
            toGoal.y = 0;
            float distance = toGoal.magnitude;

            // 目標座標再決定 
            if (m_moveTimer < 0    // 規定時間経過した？
                || distance < m_goalReachRadius)    // ゴールに到達した？
            {
                // 時間再設定 
                m_moveTimer = m_goalTimeoutSec;

                // 目標座標抽選
                Vector2 p = Random.insideUnitCircle * m_goalRadius;
                m_goal = new Vector3(p.x, 0, p.y);

                // 目標座標をデバッグ表示
                SXG_DebugDrawPositionMarker(m_goal);
            }

            // 目標へ向く
            if (0.01f < distance)
            {
                SetCaterpillarTowardWorldDir(m_nowRotation, toGoal.normalized, forwardPower: m_movePower);
            }
            else
            {
                // 目標に近すぎて正しく向きを計算できない場合の保険処理 
                SXG_SetCaterpillarPower(1.0f, 1.0f);
            }
        }

#endregion
